# MiniLang Compiler – Project 3
Semantic Analysis & Code Generation

## 1. Project Description
This project implements the **Semantic Analysis** and **Code Generation** phases of a MiniLang compiler.  
It is built on top of the parser and AST developed in **Project 2**.

The compiler processes a MiniLang source file and performs:
1. Parsing (Bison + Flex)
2. Abstract Syntax Tree (AST) construction
3. Semantic analysis (type checking, scope resolution)
4. Stack-based bytecode generation
5. Execution on a custom virtual machine (VM)

---

## 2. Supported Language Features
MiniLang supports the following constructs:

- Variable declarations: `int`, `float`, `string`, `bool`
- Arithmetic expressions: `+`, `-`, `*`, `/`
- Comparison operators: `>`, `<`, `==`
- Assignment statements
- Print statements
- Control flow:
  - `if / else`
  - `while`
  - `for`
- Nested blocks with proper scoping and shadowing

---

## 3. Compiler Architecture

Source Code
↓
Parser (Bison)
↓
Abstract Syntax Tree (AST)
↓
Semantic Analysis
(Type Checking & Scope Resolution)
↓
Bytecode Generation
↓
Virtual Machine Execution

markdown
Kodu kopyala

---

## 4. Semantic Analysis
The semantic analysis phase validates program correctness beyond syntax rules.

### Implemented Semantic Checks
- **Type checking**
  - Assignment compatibility
  - Expression type validation
- **Variable resolution**
  - Variables must be declared before use
- **Scope analysis**
  - Nested scopes supported
  - Variable shadowing handled correctly
- **Control flow validation**
  - Conditions in `if` and `while` must be boolean
- **Error reporting**
  - Clear semantic error messages
  - Compilation stops if semantic errors are found

### Example Semantic Error
```ml
int a = "hello";
Output:

css
Kodu kopyala
[Semantic Error] line X: Type mismatch in variable initializer
5. Code Generation
The compiler generates stack-based bytecode (Option A).

Why Stack-Based Bytecode?
Easier to implement and debug

Independent of real hardware architectures

Suitable for educational compiler projects

Bytecode Features
Stack-based execution model

Instructions include:

PUSH_INT, LOAD, STORE

ADD, SUB, MUL, DIV

JMP, JMPF

PRINT

Executed by a custom virtual machine

6. Project Structure
bash
Kodu kopyala
.
├── ast.c / ast.h          # AST definitions
├── parser.y               # Bison grammar
├── lexer.l                # Flex lexer
├── main.c                 # Compiler pipeline
├── sem/                   # Semantic analysis
│   ├── types.c / types.h
│   ├── symbol.c / symbol.h
│   └── sema.c / sema.h
├── cg/                    # Code generation & VM
│   ├── bytecode.c / bytecode.h
│   ├── codegen.c / codegen.h
│   └── vm.c / vm.h
├── tests/                 # Test programs
└── README.md
7. Build Instructions
Requirements
GCC or Clang

Bison

Flex

Step 1: Generate Parser and Lexer
bash
Kodu kopyala
bison -d parser.y
flex lexer.l
Step 2: Compile the Project
bash
Kodu kopyala
gcc -Wall -Wextra -g \
  ast.c \
  parser.tab.c lex.yy.c \
  sem/types.c sem/symbol.c sem/sema.c \
  cg/bytecode.c cg/codegen.c cg/vm.c \
  main.c \
  -o minilang
Note: Warnings generated by Flex (unused helper functions) are expected and do not affect execution.

8. Running the Compiler
Run with a MiniLang source file
bash
Kodu kopyala
./minilang test.minilang
9. Test Programs
Valid Example
ml
Kodu kopyala
int main {
    int a = 5;
    int b = 3;
    if (a > b) {
        print(a + b);
    } else {
        print("a is not greater than b");
    }
}
Output:

Kodu kopyala
8
Invalid Example
ml
Kodu kopyala
int main {
    int x = "hello";
}
Output:

css
Kodu kopyala
[Semantic Error] line X: Type mismatch in variable initializer
Loop Example
ml
Kodu kopyala
int main {
    int i = 0;
    while (i < 3) {
        print(i);
        i = i + 1;
    }
}
Output:

Kodu kopyala
0
1
2
10. Limitations
Only a single main program block is supported

User-defined functions are not implemented (not required for this project)
